#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

REPOS=(
    "ttf-ms-win11-auto"
    "ttf-ms-win11-fod-auto"
)

clean() {
    rm -f pkgs/*.{json,json.tmp}
    rm -rf upstream
}

clone_repo() {
    rm -rf "upstream/$1"
    mkdir -p "upstream/$1"
    git clone "https://aur.archlinux.org/$1.git" "upstream/$1"
}

update_json() {
	mkdir -p pkgs
	local pkg="$1"
	shift
	test -f "pkgs/$pkg.json" || printf '%s' '{}' >"pkgs/$pkg.json"
    jq "${@}" <"pkgs/$pkg.json" >"pkgs/$pkg.json.tmp"
    mv "pkgs/$pkg.json.tmp" "pkgs/$pkg.json"
}
export -f update_json

get_pkg_prop() {
	test -f "pkgs/$1.json" || printf '%s' '{}' >"pkgs/$1.json"
    jq -r --arg prop "$2" '.[$prop]' <"pkgs/$1.json"
}
export -f get_pkg_prop

get_output_hash() {
    local pkg="$1"
    local build_output
    local result
    set +e
    build_output="$(nix build "path:.#$pkg" --json --no-link 2>&1)"
    result=$?
    set -e

    if [[ $result -eq 0 ]]; then
        nix hash path "$(jq -r '.[0].outputs.out' <<<"$build_output")"
    else
        sed -Ene '/^[[:blank:]]+got:[[:blank:]]+(sha256-.{44})$/{s//\1/;p}' <<<"$build_output"
    fi
}
export -f get_output_hash

update_pkg() {
    local repo="$1"
    local pkg="$2"
    (
        source "upstream/$repo/PKGBUILD"
        version="$pkgver-$pkgrel"
        iso="$_iso"
        archive="$(
            sed -Ene '/7z e -aoa/{s|^.*\$\{_mountpoint\}/||; s/".*//;p}' \
                <"upstream/$repo/PKGBUILD"
        )"
		parent_dir="$(
			sed -Ene '/^\s*7z e -aoa/{n;s|^\s*||;s|\*".\{.*||;s|[{}"]||g;p}' \
				<"upstream/$repo/PKGBUILD"
		)"

        _package() {
            echo "ðŸŸ¢ $pkg: Updating package to version $version..."
			local files=( "$@" )
            local current_version="$(get_pkg_prop "$pkg" version || echo "")"
            local current_output_hash="$(get_pkg_prop "$pkg" outputHash || echo "")"
            if [ "$current_version" == "$version" ] && [ "$current_output_hash" != "" ]; then
                echo "âœ… Package '$pkg' is up to date (version $version). Skipping."
                return
            fi
            update_json "$pkg" '
						setpath(["version"]; $version) |
						setpath(["repo"]; $repo) |
						setpath(["iso"]; $iso) |
						setpath(["archive"]; $archive) |
						setpath(["parentDir"]; $parent_dir) |
						setpath(["files"]; $files) |
						setpath(["outputHash"]; "")' \
                --arg version "$version" \
				--arg repo "$repo" \
                --arg iso "$iso" \
                --arg archive "$archive" \
                --arg parent_dir "$parent_dir" \
                --argjson files "$(printf '%s\n' "${files[@]}" | sort | jq -R . | jq -s .)"
            echo "âŒ› $pkg: Calculating output hash for package, please wait..."
            local output_hash=$(get_output_hash "$pkg")
            update_json "$pkg" 'setpath(["outputHash"]; $outputHash)' \
                --arg outputHash "$output_hash"
            echo "âœ… $pkg: Updated package to version $version."
        }
        "package_$pkg"
    )
}
export -f update_pkg

update_from_repo() {
    local repo="$1"
    packages=($(
        sed -Ene 's/^[[:blank:]]*package_(ttf-ms-win11-[^[:blank:]]+)[[:blank:]]*\(\)[[:blank:]]*\{?$/\1/p' "upstream/$repo/PKGBUILD"
    ))

    parallel --halt now,fail=1 --line-buffer update_pkg "$repo" {} ::: "${packages[@]}"
}

update_all() {
    for repo in "${REPOS[@]}"; do
        clone_repo "$repo"
        update_from_repo "$repo"
		extract_names
    done
}

extract_font_names_from_pkg() {
	local pkg="$1"
	declare -a font_names=()
	echo "ðŸŸ¢ $pkg: Extracting font names..."
	OUTPATH=$(nix build path:.#$pkg --no-link --print-out-paths)
	while read fontfile; do
		font_name="$(python3 -c "from sys import argv; import fontforge; font = fontforge.open(argv[1]); print(font.familyname)" "${fontfile}" 2>/dev/null)"
		font_names+=("$font_name")
	done < <(find "$OUTPATH" -type f -name "*.ttf" -o -name "*.otf" -o -name "*.ttc" | sort)
	update_json "$pkg" 'setpath(["fontNames"]; $font_names)' \
		--argjson font_names "$(printf '%s\n' "${font_names[@]}" | sort | uniq | jq -R . | jq -s .)"
	echo "âœ… $pkg: Extracted font names."
}
export -f extract_font_names_from_pkg

extract_names() {
    all_pkgs=( $(cd pkgs && ls | sed 's/\.json$//' | sort) )
	parallel --halt now,fail=1 --line-buffer extract_font_names_from_pkg {} ::: "${all_pkgs[@]}"

	for pkg in "${all_pkgs[@]}"; do
		echo "- \`$pkg\`:"
		<"pkgs/$pkg.json" jq -r '.fontNames | .[]' | xargs -d$'\n' printf "  - *%s*\n"
	done >extracted-names.md.tmp

    echo "ðŸŸ¢ Updating README.md..."
	awk '
		/<!-- begin generated by extract-names -->/ {
			print;
			while ((getline line <"extracted-names.md.tmp") > 0) {
				print line;
			}
			skip = 1;
			next;
		}
		/<!-- end generated by extract-names -->/ {
			skip = 0;
			print;
			next;
		}
		!skip' README.md >README.md.tmp
    mv README.md.tmp README.md
    rm -f extracted-names.md.tmp
	echo "âœ… Done."
}

case "${1:-}" in
update)
    update_all
    ;;
force-update)
    clean
    update_all
    ;;
*)
    echo "Usage: $0 {clean|update|force-update}"
    exit 1
    ;;
esac
