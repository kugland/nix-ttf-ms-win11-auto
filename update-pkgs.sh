#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

REPOS=(
    "ttf-ms-win11-auto"
    "ttf-ms-win11-fod-auto"
)

clean() {
    rm -f pkgs.json pkgs.tmp.json
    rm -rf upstream
}

update_json() {
    jq -S "${@}" <pkgs.json >pkgs.tmp.json
    mv pkgs.tmp.json pkgs.json
}

get_pkg_prop() {
    jq -r --arg pkg "$1" --arg prop "$2" '.[$pkg].[$prop]' <pkgs.json
}

clone_repo() {
    rm -rf "upstream/$1"
    mkdir -p "upstream/$1"
    git clone "https://aur.archlinux.org/$1.git" "upstream/$1"
}

get_output_hash() {
    local pkg="$1"
    local build_output
    local result
    set +e
    build_output="$(nix build "path:.#$pkg" --json --no-link 2>&1)"
    result=$?
    set -e

    if [[ $result -eq 0 ]]; then
        nix hash path "$(jq -r '.[0].outputs.out' <<<"$build_output")"
    else
        sed -Ene '/^[[:blank:]]+got:[[:blank:]]+(sha256-.{44})$/{s//\1/;p}' <<<"$build_output"
    fi
}

update_pkg() {
    local repo="$1"
    local pkg="$2"
    (
        source "upstream/$repo/PKGBUILD"
        version="$pkgver-$pkgrel"
        iso="$_iso"
        archive="$(
            sed -Ene '/7z e -aoa/{s|^.*\$\{_mountpoint\}/||; s/".*//;p}' \
                <"upstream/$repo/PKGBUILD"
        )"
		parent_dir="$(
			sed -Ene '/^\s*7z e -aoa/{n;s|^\s*||;s|\*".\{.*||;s|[{}"]||g;p}' \
				<"upstream/$repo/PKGBUILD"
		)"

        _package() {
            echo "Updating package '$pkg' to version $version..."
            current_version="$(get_pkg_prop "$pkg" version || echo "")"
            current_output_hash="$(get_pkg_prop "$pkg" outputHash || echo "")"
            if [ "$current_version" == "$version" ] && [ "$current_output_hash" != "" ]; then
                echo "✅ Package '$pkg' is up to date (version $version). Skipping."
                return
            fi
            update_json '
						setpath([$pkg, "version"]; $version) |
						setpath([$pkg, "iso"]; $iso) |
						setpath([$pkg, "archive"]; $archive) |
						setpath([$pkg, "parentDir"]; $parent_dir) |
						setpath([$pkg, "files"]; $files) |
						setpath([$pkg, "outputHash"]; "")' \
                --arg pkg "$pkg" \
                --arg version "$version" \
                --arg iso "$iso" \
                --arg archive "$archive" \
                --arg parent_dir "$parent_dir" \
                --argjson files "$(printf '%s\n' "$@" | jq -R . | jq -s .)"
            echo "⌛ Calculating output hash for package '$pkg', please wait..."
            output_hash=$(get_output_hash "$pkg")
            update_json 'setpath([$pkg, "outputHash"]; $outputHash)' \
                --arg pkg "$pkg" \
                --arg outputHash "$output_hash"
            echo "✅ Updated package '$pkg' to version $version."
        }
        "package_$pkg"
    )
}

update_from_repo() {
    local repo="$1"
    packages=($(
        sed -Ene 's/^[[:blank:]]*package_(ttf-ms-win11-[^[:blank:]]+)[[:blank:]]*\(\)[[:blank:]]*\{?$/\1/p' "upstream/$repo/PKGBUILD"
    ))

    for pkg in "${packages[@]}"; do
        update_pkg "$repo" "$pkg"
    done
}

update_all() {
    if ! [ -f pkgs.json ]; then
        printf '%s' '{}' >pkgs.json
    fi
    for repo in "${REPOS[@]}"; do
        clone_repo "$repo"
        update_from_repo "$repo"
    done
}

extract_names() {
    echo "Extracting font names for README.md..."
    all_pkgs=($(jq -r 'keys | .[]' <pkgs.json))
    for pkg in "${all_pkgs[@]}"; do
        typeset -a font_names
        font_names=()
        OUTPATH=$(nix build path:.#$pkg --no-link --print-out-paths)
        while read fontfile; do
            font_name="$(python3 -c "from sys import argv; import fontforge; font = fontforge.open(argv[1]); print(font.familyname)" "${fontfile}" 2>/dev/null)"
            font_names+=("$font_name")
        done < <(find "$OUTPATH" -type f -name "*.ttf" -o -name "*.otf" -o -name "*.ttc")
        echo "- \`${pkg}\`:"
        printf "  - *%s*\n" "${font_names[@]}" | sort | uniq
    done >extracted-names.md

    awk '
		/<!-- begin generated by extract-names -->/ {
			print;
			while ((getline line <"extracted-names.md") > 0) {
				print line;
			}
			skip = 1;
			next;
		}
		/<!-- end generated by extract-names -->/ {
			skip = 0;
			print;
			next;
		}
		!skip' README.md >README.md.tmp
    mv README.md.tmp README.md
    rm -f extracted-names.md
}

case "${1:-}" in
clean)
    clean
    ;;
update)
    update_all
    ;;
force-update)
    clean
    update_all
    ;;
extract-names)
    extract_names
    ;;
*)
    echo "Usage: $0 {clean|update|force-update|extract-names}"
    exit 1
    ;;
esac
